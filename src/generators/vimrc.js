// Shared vimrc generation (Step 6 in PLAN.md).

const EXCLUDED_INTENT_PREFIXES = [
  "lsp.",
  "git.",
  "harpoon.",
  "todo.",
  "plugin.",
];

const MODE_TO_MAP = {
  n: { noremap: "nnoremap", map: "nmap" },
  i: { noremap: "inoremap", map: "imap" },
  v: { noremap: "vnoremap", map: "vmap" },
  x: { noremap: "xnoremap", map: "xmap" },
  s: { noremap: "snoremap", map: "smap" },
  o: { noremap: "onoremap", map: "omap" },
  c: { noremap: "cnoremap", map: "cmap" },
  t: { noremap: "tnoremap", map: "tmap" },
};

export function generateVimrc(keymaps = []) {
  const lines = [
    '" Generated by nvim-keymap-migrator',
    '" Shared pure-Vim mappings',
    "",
  ];

  let generated = 0;
  let skipped = 0;

  for (const keymap of keymaps) {
    const line = toVimMapLine(keymap);
    if (!line) {
      skipped += 1;
      continue;
    }
    lines.push(line);
    generated += 1;
  }

  if (generated === 0) {
    lines.push('" No pure Vim-compatible mappings detected.');
  }

  lines.push("");
  lines.push(`" Generated mappings: ${generated}`);
  lines.push(`" Skipped mappings: ${skipped}`);

  return `${lines.join("\n")}\n`;
}

function toVimMapLine(keymap = {}) {
  const mode = normalizeMode(keymap.mode);
  if (!mode) return null;

  const lhs = readField(keymap, "lhs");
  const rhs = readRhs(keymap);
  if (!lhs || !rhs || rhs === "<Lua function>") {
    return null;
  }

  if (lhs.startsWith("<Plug>") || lhs.startsWith("<plug>")) {
    return null;
  }

  const intent = typeof keymap.intent === "string" ? keymap.intent : "";
  if (shouldExcludeIntent(intent)) {
    return null;
  }

  const opts = getOpts(keymap);
  const mapCmd = pickMapCommand(mode, opts.noremap);
  const flags = [];
  if (truthy(opts.silent)) flags.push("<silent>");
  if (truthy(opts.expr)) flags.push("<expr>");
  if (truthy(opts.nowait)) flags.push("<nowait>");
  if (truthy(opts.buffer)) flags.push("<buffer>");

  const prefix = [mapCmd, ...flags].join(" ");
  return `${prefix} ${lhs} ${rhs}`;
}

function pickMapCommand(mode, noremap) {
  const table = MODE_TO_MAP[mode] ?? { noremap: "noremap", map: "map" };
  return truthy(noremap) ? table.noremap : table.map;
}

function normalizeMode(mode) {
  if (typeof mode !== "string") return null;
  if (mode.length === 0) return null;
  if (MODE_TO_MAP[mode]) return mode;
  return null;
}

function readRhs(keymap) {
  const rawRhs = readField(keymap, "raw_rhs");
  if (rawRhs) return rawRhs;
  return readField(keymap, "rhs");
}

function readField(obj, name) {
  if (!obj || typeof obj !== "object") return "";
  const value = obj[name];
  return typeof value === "string" ? value.trim() : "";
}

function getOpts(keymap) {
  if (keymap && keymap.opts && typeof keymap.opts === "object") {
    return keymap.opts;
  }

  return {
    silent: keymap?.silent,
    noremap: keymap?.noremap ?? true,
    buffer: keymap?.buffer,
    nowait: keymap?.nowait,
    expr: keymap?.expr,
  };
}

function shouldExcludeIntent(intent) {
  if (!intent) return false;
  return EXCLUDED_INTENT_PREFIXES.some((prefix) => intent.startsWith(prefix));
}

function truthy(value) {
  return value === true || value === 1;
}

export function isPureVimMapping(keymap) {
  return Boolean(toVimMapLine(keymap));
}
