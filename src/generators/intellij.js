// IntelliJ/IdeaVim generation (Step 7 in PLAN.md).

import { loadMappings, lookupIntent } from '../registry.js';

const MODE_TO_MAP = {
  n: { noremap: 'nnoremap', map: 'nmap' },
  i: { noremap: 'inoremap', map: 'imap' },
  v: { noremap: 'vnoremap', map: 'vmap' },
  x: { noremap: 'xnoremap', map: 'xmap' },
  s: { noremap: 'snoremap', map: 'smap' },
  o: { noremap: 'onoremap', map: 'omap' },
  c: { noremap: 'cnoremap', map: 'cmap' },
  t: { noremap: 'tnoremap', map: 'tmap' },
};

export function generateIdeaVimrc(keymaps = [], options = {}) {
  const registry = options.registry ?? loadMappings();
  const mapped = [];
  const manual = [];
  const seen = new Set();

  for (const keymap of keymaps) {
    const lhs = readString(keymap.lhs);
    const mode = normalizeMode(keymap.mode);
    const intent = readString(keymap.intent);
    if (!lhs || !mode || !intent) {
      continue;
    }

    const action = lookupIntent(intent, 'intellij', registry);
    if (!action) {
      manual.push({
        lhs,
        intent,
      });
      continue;
    }

    const opts = readOpts(keymap);
    const mapCmd = pickMapCommand(mode, opts.noremap);
    const flags = [];
    if (truthy(opts.silent)) flags.push('<silent>');
    if (truthy(opts.expr)) flags.push('<expr>');
    if (truthy(opts.nowait)) flags.push('<nowait>');
    if (truthy(opts.buffer)) flags.push('<buffer>');

    const line = `${[mapCmd, ...flags].join(' ')} ${lhs} <Action>(${action})`;
    const key = `${mode}|${lhs}|${action}|${mapCmd}|${flags.join(',')}`;
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);
    mapped.push(line);
  }

  const lines = [
    '" Generated by nvim-keymap-migrator',
    '" IntelliJ IdeaVim action mappings',
    '',
  ];

  if (mapped.length === 0) {
    lines.push('" No IDE-translatable mappings detected.');
  } else {
    lines.push(...mapped);
  }

  lines.push('');
  lines.push(`" Generated actions: ${mapped.length}`);
  lines.push(`" Manual mappings: ${manual.length}`);

  if (manual.length > 0) {
    lines.push('" Manual review:');
    for (const item of manual.slice(0, 20)) {
      lines.push(`" ${item.lhs} -> ${item.intent}`);
    }
  }

  return `${lines.join('\n')}\n`;
}

function normalizeMode(mode) {
  if (typeof mode !== 'string' || !MODE_TO_MAP[mode]) {
    return null;
  }
  return mode;
}

function pickMapCommand(mode, noremap) {
  const table = MODE_TO_MAP[mode];
  return truthy(noremap) ? table.noremap : table.map;
}

function readString(value) {
  return typeof value === 'string' ? value.trim() : '';
}

function readOpts(keymap) {
  if (keymap && keymap.opts && typeof keymap.opts === 'object') {
    return keymap.opts;
  }

  return {
    silent: keymap?.silent,
    noremap: keymap?.noremap ?? true,
    buffer: keymap?.buffer,
    nowait: keymap?.nowait,
    expr: keymap?.expr,
  };
}

function truthy(value) {
  return value === true || value === 1;
}
