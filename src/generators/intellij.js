// IntelliJ/IdeaVim generation (Step 7 in PLAN.md).

import { readFileSync } from "node:fs";
import { join } from "node:path";
import { fileURLToPath } from "node:url";
import { loadMappings, lookupIntent } from "../registry.js";

const ROOT = fileURLToPath(new URL("../..", import.meta.url));
const TEMPLATES_DIR = join(ROOT, "templates");

function loadDefaults() {
  try {
    const raw = readFileSync(join(TEMPLATES_DIR, "defaults.json"), "utf8");
    return JSON.parse(raw);
  } catch {
    return { keymaps: [] };
  }
}

const MODE_TO_MAP = {
  n: { noremap: "nnoremap", map: "nmap" },
  i: { noremap: "inoremap", map: "imap" },
  v: { noremap: "vnoremap", map: "vmap" },
  x: { noremap: "xnoremap", map: "xmap" },
  s: { noremap: "snoremap", map: "smap" },
  o: { noremap: "onoremap", map: "omap" },
  c: { noremap: "cnoremap", map: "cmap" },
  t: { noremap: "tnoremap", map: "tmap" },
};

export function generateIdeaVimrc(keymaps = [], options = {}) {
  const registry = options.registry ?? loadMappings();
  const defaults = loadDefaults();
  const defaultKeymaps = Array.isArray(defaults.keymaps)
    ? defaults.keymaps
    : [];

  const userBindings = new Set();
  for (const keymap of keymaps) {
    const mode = normalizeMode(keymap.mode);
    const lhs = readString(keymap.lhs);
    if (!mode || !lhs) {
      continue;
    }
    userBindings.add(`${mode}|${lhs}`);
  }

  const defaultLines = [];
  let defaultsAdded = 0;
  for (const def of defaultKeymaps) {
    const mode = normalizeMode(def.mode);
    const lhs = readString(def.lhs);
    if (!mode || !lhs) continue;
    if (userBindings.has(`${mode}|${lhs}`)) {
      continue;
    }

    const intent = readString(def.intent);
    const action = lookupIntent(intent, "intellij", registry);
    if (!action) continue;

    const mapCmd = pickMapCommand(mode);
    const line = `${mapCmd} ${def.lhs} <Action>(${action})`;
    defaultLines.push(line);
    defaultsAdded += 1;
  }

  const mapped = [];
  const pureVimLines = [];
  const manual = [];
  const seen = new Set();

  for (const keymap of keymaps) {
    const lhs = readString(keymap.lhs);
    const mode = normalizeMode(keymap.mode);
    const intent = readString(keymap.intent);
    if (!lhs || !mode) {
      continue;
    }

    // No intent - output as pure Vim mapping (e.g., K, J for native Vim motions)
    if (!intent) {
      const opts = readOpts(keymap);
      const rhs = readRhs(keymap);
      if (!rhs || rhs === "<Lua function>") {
        continue;
      }

      // Use nnoremap for all pure vim mappings (safer for overriding defaults)
      const mapCmd = "nnoremap";
      const flags = [];
      if (truthy(opts.silent)) flags.push("<silent>");
      if (truthy(opts.expr)) flags.push("<expr>");
      if (truthy(opts.nowait)) flags.push("<nowait>");
      if (truthy(opts.buffer)) flags.push("<buffer>");

      const line = `${[mapCmd, ...flags].join(" ")} ${lhs} ${rhs}`;
      const key = `${mode}|${lhs}|${mapCmd}|${flags.join(",")}`;
      if (!seen.has(key)) {
        seen.add(key);
        pureVimLines.push(line);
      }
      continue;
    }

    const action = lookupIntent(intent, "intellij", registry);
    if (!action) {
      manual.push({
        lhs,
        intent,
      });
      continue;
    }

    const opts = readOpts(keymap);
    const mapCmd = pickMapCommand(mode, opts.noremap);
    const flags = [];
    if (truthy(opts.silent)) flags.push("<silent>");
    if (truthy(opts.expr)) flags.push("<expr>");
    if (truthy(opts.nowait)) flags.push("<nowait>");
    if (truthy(opts.buffer)) flags.push("<buffer>");

    const line = `${[mapCmd, ...flags].join(" ")} ${lhs} <Action>(${action})`;
    const key = `${mode}|${lhs}|${action}|${mapCmd}|${flags.join(",")}`;
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);
    mapped.push(line);
  }

  const lines = [
    '" Generated by nvim-keymap-migrator',
    '" IntelliJ IdeaVim action mappings',
    "",
  ];

  if (defaultLines.length > 0) {
    lines.push('" Default LSP keymaps (from Neovim defaults)');
    lines.push(...defaultLines);
    lines.push("");
  }

  if (pureVimLines.length > 0) {
    lines.push('" Pure Vim mappings (native Vim motions)');
    lines.push(...pureVimLines);
    lines.push("");
  }

  if (mapped.length === 0 && pureVimLines.length === 0) {
    lines.push('" No IDE-translatable mappings detected.');
  } else {
    lines.push(...mapped);
  }

  lines.push("");
  lines.push(`" Generated actions: ${defaultLines.length + mapped.length}`);
  lines.push(`" Pure Vim mappings: ${pureVimLines.length}`);
  lines.push(`" Manual mappings: ${manual.length}`);

  if (manual.length > 0) {
    lines.push('" Manual review:');
    for (const item of manual.slice(0, 20)) {
      lines.push(`" ${item.lhs} -> ${item.intent}`);
    }
  }

  const text = `${lines.join("\n")}\n`;
  return { text, defaultsAdded };
}

function normalizeMode(mode) {
  if (typeof mode !== "string" || !MODE_TO_MAP[mode]) {
    return null;
  }
  return mode;
}

function pickMapCommand(mode, noremap = false) {
  const table = MODE_TO_MAP[mode];
  return noremap ? table.noremap : table.map;
}

function readRhs(keymap) {
  const rawRhs = keymap?.raw_rhs;
  if (typeof rawRhs === "string" && rawRhs.trim()) {
    return rawRhs.trim();
  }
  const rhs = keymap?.rhs;
  return typeof rhs === "string" ? rhs.trim() : "";
}

function readString(value) {
  return typeof value === "string" ? value.trim() : "";
}

function readOpts(keymap) {
  if (keymap && keymap.opts && typeof keymap.opts === "object") {
    return keymap.opts;
  }

  return {
    silent: keymap?.silent,
    noremap: keymap?.noremap ?? false,
    buffer: keymap?.buffer,
    nowait: keymap?.nowait,
    expr: keymap?.expr,
  };
}

function truthy(value) {
  return value === true || value === 1;
}
